package main

import (
    "io"
    "os"
)

// 结果： go build -gcflags '-m -l' ./main.go
// # command-line-arguments
// ./main.go:13:14: str does not escape
// ./main.go:15:12: str + "\n" escapes to heap
// ./main.go:18:15: str does not escape
// ./main.go:19:5: moved to heap: result
// ./main.go:19:19: make([]rune, 0, len(str)) escapes to heap
// ./main.go:22:15: func literal escapes to heap
// ./main.go:20:29: ([]rune)(str) does not escape
// ./main.go:9:19: string(*ReverseA("golang go")) does not escape
// <autogenerated>:1: .this does not escape

// 解析：① 如果一个变量被取地址，通过函数返回指针值返回也会产生逃逸。
// ② 闭包，编译器不确定切片容量时，是否要扩容的时候，放到堆上，以致产生逃逸。

// 如何得知变量是分配在栈（stack）上还是堆（heap）上？
// Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。
// 知道变量的存储位置确实和效率编程有关系。
// 如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上，
// 如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。
// 如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。

func main() {
    Println(string(*ReverseA("golang go"))) // 这里是否会发生逃逸?
}

func Println(str string) {
    // str + "\n" escapes to heap
    io.WriteString(os.Stdout,
        str+"\n")
}

func ReverseA(str string) *[]rune {
    //  make([]rune, 0, len(str)) escapes to heap
    result := make([]rune, 0, len(str))
    for _, v := range []rune(str) {
        v := v
        defer func() {
            result = append(result, v)
        }()
    }
    return &result
}

// 优化后的代码
/**
package main

import (
 "io"
 "os"
)

func main() {
    result := []rune("Ding Ding")
    ReverseB(result)
    Println(string(result))
}

func ReverseB(runes []rune) {
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
}

func Println(str string) {
    io.WriteString(os.Stdout,
      str+"\n")
}
*/
